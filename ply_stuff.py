from plyfile import PlyData, PlyElement
import numpy as np
import pandas as pd

""" 
Contents of the gaussian splat PLY:

ply
format binary_little_endian 1.0
comment Generated by Nerstudio 1.1.5
comment Vertical Axis: z
element vertex 500478
property float x
property float y
property float z
property float nx
property float ny
property float nz
property float f_dc_0
property float f_dc_1
property float f_dc_2
property float opacity
property float scale_0
property float scale_1
property float scale_2
property float rot_0
property float rot_1
property float rot_2
property float rot_3
end_header

The goal is to add class_id to the PLY file: 

- Option 1: property list uchar float class_id. Problem: can't memory map list properties unless they have fixed size. In a pandas dataframe, it's more efficient to have multiple dataframe columns for each class_id anyway.
- Option 2: multiple class_id properties, e.g., class_id_0, class_id_1, class_id_2, etc. Enforces limited amount of classes, and requires deciding how the classes are determined (top 5 classes with highest similarity score?). Most efficient for memory mapping and dataframes.

At first, we implement Option 2, assuming 3 classes.
"""

# Path to files
sparse_ply = "../data/nerfstudio/garden_8/sparse_pc.ply"  # 42k vertex, pos + rgb
gaussian_ply = "../data/.temp/splat.ply"  # 500k vertex, pos + normal + opacity + scale + rotation etc
dummy_ply = "../data/.temp/dummy_sparse.ply"  # 5 vertex, pos + rgb

# Read inputs
plydata = PlyData.read(dummy_ply)

# Dummy class_id dataframe
def create_dummy_class_id_df():
    # class_id=0 -> no class, or 'other'.
    data = {
        'vertex_index': [0, 1, 2, 3, 4],
        # 'class_0': [0, 1, 1, 1, 2],
        # 'class_1': [0, 0, 2, 2, 0],
        # 'class_2': [0, 0, 0, 3, 0],
        'class_id': [
            [1],
            [1],
            [1, 2],
            [1, 2, 3],
            []
        ]
    }
    df = pd.DataFrame(data)
    df.to_csv("dummy_vertex_classes.csv", index=False, float_format="%.2f")
    return df
class_id_df = create_dummy_class_id_df()
class_id_np = class_id_df['class_id'].to_numpy()


print("Class ID DataFrame:", class_id_df)
print("Class ID Numpy Array:", class_id_np)





# Convert class_id_array to a list of tuples with list structure
# 'list' property values in plyfile must be tuples: (len, [items])
class_id_tuples = [(len(lst), lst) for lst in class_id_np]

old_vertices = plydata['vertex'].data
vertices_count = plydata['vertex'].count

# Extend dtype
old_dtype = old_vertices.dtype.descr  # list of (name, type)
extended_dtype = old_dtype + [('class_id', object)]  # list properties must be object dtype

# Create array with extended data
new_vertex_array = np.empty(vertices_count, dtype=extended_dtype)
for name in old_vertices.dtype.names:
    new_vertex_array[name] = old_vertices[name]
new_vertex_array['class_id'] = class_id_tuples  # Assume all indices have at least an empty list of class ids

# New PlyElement first
new_vertex_el = PlyElement.describe(
    new_vertex_array,
    'vertex',
    comments=plydata['vertex'].comments
)

# New PlyData with created PlyElement
new_plydata = PlyData(
    [new_vertex_el],
    text=True
)

new_plydata.write('output_with_class_id.ply')